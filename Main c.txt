// PIC32 control of pneumatic actuator

#include<xc.h>                      // processor SFR definitions
#include<sys/attribs.h>             // __ISR macro
#include<string.h>
#include<stdio.h>
#include<stdlib.h>

#include "init.h"
#include "ili9341.h"
#include "adc.h"
#include "uart.h"

#include<math.h>
#define MAX_MESSAGE_LENGTH 200
#define SAMPLE_TIME 10

double transfer_function(int voltage){
    /* Voltage divider, as built, reduces voltage from 5v to 3.27v
     int voltage has a value between 0 and 1023 (PIC32 has a 10-bit resolution ADC)
     Pressure sensor reads gage pressure
     Output is proportional to the difference between 
     applied pressure and atmospheric (ambient) pressure 
     */

    double v_supply = 3.36;
    double v_output = (voltage/1023.)*v_supply;
    
//    double v_min = v_supply * 0;
    double v_max = v_supply * 1;
    
    // Documented transfer function
//    double pressure = (v_min + ((v_max-v_min)/(0.8*v_supply))*(v_output-(0.1*v_supply)))+14.7;
    
    // Proportional transfer function
    double pressure = (((v_output/v_max))*150)-14.7;
    
    return pressure;
}

void _mon_putc (char c){
   while (U1STAbits.UTXBF); // Wait til current transmission is complete
   U1TXREG = c;
}


unsigned int adc_sample_convert_1(int pin) { // sample & convert the value on the given
// adc pin the pin should be configured as an
// analog input in AD1PCFG
unsigned int elapsed = 0, finish_time = 0;
AD1CHSbits.CH0SA = pin; // connect chosen pin to MUXA for sampling
AD1CON1bits.SAMP = 1; // start sampling
elapsed = _CP0_GET_COUNT();
finish_time = elapsed + SAMPLE_TIME;
while (_CP0_GET_COUNT() < finish_time) {
; // sample for more than 250 ns
}
AD1CON1bits.SAMP = 0; // stop sampling and start converting
while (!AD1CON1bits.DONE) {
; // wait for the conversion process to finish
}
return ADC1BUF0; // read the buffer with the result
}

int main() {
    char message[MAX_MESSAGE_LENGTH];
    int  pressure_value = 100;
    int  solenoid_value = 0;
//    double pressure = 0;
//    
    int test_voltage = 0;
    
    // Touch Sensor
//    ANSELBbits.ANSB2 = 1;           // sets RB2 (AN4) as analog
//    TRISBbits.TRISB2 = 1;           // sets RB2 as input
////    
////    // Pressure Sensor
//    ANSELBbits.ANSB3 = 1;           // sets RB3 (AN5) as analog
//    TRISBbits.TRISB3 = 1;           // sets RB3 as input
//    
    TRISBbits.TRISB12 = 0;          // RB12 as output (pwm @ motor driver)
    TRISBbits.TRISB10 = 0;          // RB10 as output

    LATBbits.LATB10 = 0;            // set RB10 as high
    
    // ADC process (analog to digital converter)
//    AD1CON1bits.SSRC = 0x7;
//    AD1CON1bits.ASAM = 0;
//    AD1CON3bits.ADCS = 2;
//    AD1CON3bits.SAMC = 20;
//    AD1CON1bits.ADON = 1;
    ANSELAbits.ANSA0 = 1;
    TRISAbits.TRISA0 = 1;
    
    AD1CON3bits.ADCS = 2; // ADC clock period is Tad = 2*(ADCS+1)*Tpb =
    AD1CON1bits.ON = 1;
    AD1CON1bits.FORM = 0b100;

    init_pic();
    
    // variables
    int voltage = 0;
    int cap = 0;
    char temp_msg[30]; 

    // added for PWM
    // pressure control
    RPB11Rbits.RPB11R = 0b0101; // Set pin B11 to OC2
    T2CONbits.TCKPS = 2;     // set the timer prescaler so that you can use the largest PR2 value as possible without going over 65535 and the frequency is 50Hz N = 8 
    PR2 = 3150;
    TMR2 = 0;                // initial TMR2 count is 0
    OC2CONbits.OCM = 0b110;  // PWM mode without fault pin; other OCxCON bits are defaults
    OC2RS = 0;             // duty cycle = OCxRS/(PR2+1) default to 0
    OC2R = 1;
    T2CONbits.ON = 1;        // turn on Timer2
    OC2CONbits.ON = 1;       // turn on OCx
        
    // solenoid
    LATBbits.LATB12 = 1;
    
    // solenoid control
    RPB13Rbits.RPB13R = 0b0110;
    OC5CONbits.OCM = 0b110;
    OC5RS = 0;
    OC5R = 1;
    OC5CONbits.ON = 1;       // turn on OCx
    // end
    __builtin_enable_interrupts();

    void delay(unsigned long int time){
            _CP0_SET_COUNT(0);
             while(_CP0_GET_COUNT() < time){}
            _CP0_SET_COUNT(0);
       }
        
    while (1) {

        _CP0_SET_COUNT(0);                  // start timer 
        readUART(message, MAX_MESSAGE_LENGTH);
        int len = strlen(message);
        char c = message[len-1];
        int x = c - '0';
            
        if (atoi(message) == 0) {
            solenoid_value = 0;
            pressure_value = 100;
        }
        else{
            message[len - 1] = '\0';
            solenoid_value = x;
            pressure_value = atoi(message);
        }
        sprintf(temp_msg, "Solenoid_value:  %d", solenoid_value);
        write_screen(28, 24, temp_msg);
        sprintf(temp_msg, "Pressure_value:  %d", pressure_value);
        write_screen(160, 24, temp_msg);
        LATBbits.LATB12 = solenoid_value;
        
//        voltage = analogRead(4)*10+BNC_cabel;
        voltage = analogRead(4)*1000000+analogRead(0);
        
//        pressure = transfer_function(voltage);       
       
//      Send message to computer
        
        char presout[50];
        sprintf(presout, "%d", voltage);
        char solenoid_str[50];
        sprintf(solenoid_str, "%d", solenoid_value);
        printf("\n");
        getchar();
        strcat(presout, solenoid_str);

        writeUART(presout);

        OC5RS = 3100;      // high level    
        OC2RS = pressure_value;   // 0 - 3100   
//        OC2RS = 2500;   // 0 - 3100  
       
        
//      end

//        sprintf(temp_msg, "Pressure value:  %d", pressure_value);
//        write_screen(28, 24, temp_msg);
        
        test_voltage = analogRead(0);
        
        sprintf(temp_msg, "Update Frequency:    %3.1f Hz", (24000000.0/_CP0_GET_COUNT()));
        write_screen(28, 40, temp_msg);
        
        sprintf(temp_msg, "Test Voltage:   %d", test_voltage);
        write_screen(28, 56, temp_msg);
        
        sprintf(temp_msg, "Pressure:   %f", transfer_function(analogRead(4)));
        write_screen(160, 56, temp_msg);
        
        sprintf(temp_msg, "RB11, Pin 22:   %d", PORTBbits.RB11);
        write_screen(28, 72, temp_msg);
        
        sprintf(temp_msg, "RB12, Pin 23:   %d", LATBbits.LATB12);
        write_screen(28, 88, temp_msg);
        
        sprintf(temp_msg, "RB13, Pin 24:   %d", LATBbits.LATB13);
        write_screen(28, 104, temp_msg);
        
 
        // ---capacitance sensor---
        cap = ctmu_read(4, (4800000/4)); // tuned
        sprintf(temp_msg, "cap %d   ", cap);
        write_screen(200, 88, temp_msg);
        
        if (cap<200){
            sprintf(temp_msg, "Touched: yes");
            while(_CP0_GET_COUNT() < 48000000 / 2 / 1000){}
        }
        else{
            sprintf(temp_msg, "Touched: no ");
        }
        write_screen(200, 104, temp_msg);
        
    }
}